// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
using Geometrize.Rasterizer;
using System;
using System.Collections.Generic;

namespace Geometrize.Shape
{
    public class RotatedEllipse : Ellipse
    {
        public RotatedEllipse(int xBound, int yBound)
            : base(xBound, yBound)
        {
            angle = Std.random(360);
        }

        public int angle;

        public override IReadOnlyList<Scanline> Rasterize()
        {
            int pointCount = 20;
            var points = new List<Point>();
            double rads = angle * (HaxeMath.PI / 180.0);
            double c = Math.Cos((double)rads);
            double s = Math.Sin((double)rads);

            for (int i = 0; i < pointCount; i++)
            {
                double rot = 360.0 / pointCount * i * (HaxeMath.PI / 180.0);
                double crx = rx * Math.Cos((double)rot);
                double cry = ry * Math.Sin((double)rot);
                int tx = (int)((crx * c) - (cry * s) + x);
                int ty = (int)((crx * s) + (cry * c) + y);
                points.Add(new Point(tx, ty));
            }

            return Scanline.Trim(Rasterizer.Rasterizer.ScanlinesForPolygon(points), xBound, yBound);
        }


        public override void Mutate()
        {
            unchecked
            {
                switch (HaxeMath.rand.Next(4))
                {
                    case 0:
                        x = Math.Clamp(x + -16 + HaxeMath.rand.Next(33), 0, xBound - 1);
                        y = Math.Clamp(y + -16 + HaxeMath.rand.Next(33), 0, xBound - 1);
                        break;

                    case 1:
                        rx = Math.Clamp(rx - 16 + HaxeMath.rand.Next(33), 1, xBound - 1);
                        break;

                    case 2:
                        ry = Math.Clamp(ry - 16 + HaxeMath.rand.Next(33), 1, xBound - 1);
                        break;

                    case 3:
                        {
                            int value4 = angle + -4 + ((int)Math.Floor((double)(9 * HaxeMath.rand.NextDouble())));
                            angle = (value4 < 0) ? 0 : ((value4 > 360) ? 360 : value4);
                            break;
                        }
                }
            }
        }


        public override IShape Clone()
        {
            return new RotatedEllipse(xBound, yBound)
            {
                x = x,
                y = y,
                rx = rx,
                ry = ry,
                angle = angle
            };
        }

        public override double[] GetRawShapeData()
        {
            return new double[]
            {
                x, y, rx, ry, angle
            };
        }
    }
}


