// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using System;
using System.Collections.Generic;

namespace Geometrize
{
    public class Bitmap
    {
        public static Bitmap CreateFromImage(Image<Rgba32> input)
        {
            Bitmap bitmap = new Bitmap
            {
                width = input.Width,
                height = input.Height,
                data = new Rgba32[input.Width * input.Height]
            };

            input.CopyPixelDataTo(bitmap.data);

            return bitmap;
        }

        public static Bitmap CreateFromSolidColor(int width, int height, Rgba32 color)
        {
            Bitmap bitmap = new Bitmap
            {
                width = width,
                height = height,
                data = (new Rgba32[(width * height)])
            };

            Array.Fill(bitmap.data, color);

            return bitmap;
        }

        public static Bitmap CreateTransparent(int width, int height)
            => CreateFromSolidColor(width, height, new Rgba32(0, 0, 0, 0));


        public int width;

        public int height;

        public Rgba32[] data;

        public Bitmap overlay;


        public Bitmap Clone()
        {
            Bitmap bitmap = new Bitmap
            {
                width = width,
                height = height,
                data = new Rgba32[data.Length]
            };

            Array.Copy(data, bitmap.data, data.Length);

            return bitmap;
        }

        public static Bitmap operator +(Bitmap left, Bitmap right)
        {
            if (left.height != right.height || left.width != right.width)
                throw new InvalidOperationException($"Bitmaps must be same size. left is {left.width}x{left.height}, right is {right.width}x{right.height}");

            var result = left.Clone();

            var blender = PixelOperations<Rgba32>.Instance.GetPixelBlender(new SixLabors.ImageSharp.GraphicsOptions() { Antialias = false, ColorBlendingMode = PixelColorBlendingMode.Normal });

            for (int y = 0; y < left.height; y++)
            {
                for (int x = 0; x < left.width; x++)
                {
                    var pos = y * left.width + x;

                    var leftPixel = left.data[pos];
                    var rightPixel = right.data[pos];

                    result.data[pos] = blender.Blend(leftPixel, rightPixel, 1);
                }
            }

            return result;
        }
    }
}


