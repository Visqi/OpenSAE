// Generated by Haxe 4.3.1

using SixLabors.ImageSharp.PixelFormats;
using System;
using System.Collections.Generic;

namespace Geometrize.Rasterizer
{
    public static class Rasterizer
    {
        public static void DrawLines(Bitmap image, Rgba32 color, IEnumerable<Scanline> lines)
        {
            unchecked
            {
                if (image == null)
                {
                    throw new Exception("FAIL: image != null");
                }

                if (lines == null)
                {
                    throw new Exception("FAIL: lines != null");
                }

                var blender = new BulkColorPixelBlender(color);

                foreach (var line in lines)
                {
                    for (int x = line.x1; x < line.x2 + 1; x++)
                    {
                        image.data[(image.width * line.y) + x] =
                            blender.Blend(image.data[(image.width * line.y) + x]); 
                    }
                }
            }
        }

        public static void CopyLines(Bitmap destination, Bitmap source, IEnumerable<Scanline> lines)
        {
            unchecked
            {
                if (destination == null)
                {
                    throw new Exception("FAIL: destination != null");
                }

                if (source == null)
                {
                    throw new Exception("FAIL: source != null");
                }

                if (lines == null)
                {
                    throw new Exception("FAIL: lines != null");
                }

                foreach (var line in lines)
                {
                    for (int x = line.x1; x < line.x2 + 1; x++)
                    {
                        destination.data[(destination.width * line.y) + x] = source.data[(source.width * line.y) + x];
                    }
                }
            }
        }


        public static List<Point> Bresenham(int x1, int y1, int x2, int y2)
        {
            unchecked
            {
                int dx = x2 - x1;
                int ix = ((dx > 0) ? 1 : 0) - ((dx < 0) ? 1 : 0);
                dx = ((dx < 0) ? (-dx) : dx) << 1;
                int dy = y2 - y1;
                int iy = ((dy > 0) ? 1 : 0) - ((dy < 0) ? 1 : 0);
                dy = ((dy < 0) ? (-dy) : dy) << 1;

                var points = new List<Point>
                {
                    new Point(x1, y1)
                };

                if (dx >= dy)
                {
                    int error = dy - (dx >> 1);
                    while (x1 != x2)
                    {
                        if ((error >= 0) && ((error != 0) || (ix > 0)))
                        {
                            error -= dx;
                            y1 += iy;
                        }

                        error += dy;
                        x1 += ix;

                        points.Add(new Point(x1, y1));
                    }

                }
                else
                {
                    int error1 = dx - (dy >> 1);
                    while (y1 != y2)
                    {
                        if ((error1 >= 0) && ((error1 != 0) || (iy > 0)))
                        {
                            error1 -= dy;
                            x1 += ix;
                        }

                        error1 += dx;
                        y1 += iy;

                        points.Add(new Point(x1, y1));
                    }

                }

                return points;
            }
        }


        public static List<Scanline> ScanlinesForPolygon(IReadOnlyList<Point> points)
        {
            var lines = new List<Scanline>();
            var edges = new List<Point>();

            for (int i = 0; i < points.Count; i++)
            {
                var p1 = points[i];
                var p2 = (i == points.Count - 1) ? points[0] : points[i + 1];
                var p1p2 = Bresenham(p1.X, p1.Y, p2.X, p2.Y);

                edges.AddRange(p1p2);
            }

            var yToXs = new Dictionary<int, List<int>>();
            foreach (var point in edges)
            {
                if (!yToXs.TryGetValue(point.Y, out var xList))
                {
                    xList = new List<int>();
                    yToXs[point.Y] = xList;
                }

                xList.Add(point.X);
            }

            foreach (int y in yToXs.Keys)
            {
                (int min, int max) = Util.GetMinMax(yToXs[y]);

                lines.Add(new Scanline(y, min, max));
            }

            return lines;
        }
    }
}


