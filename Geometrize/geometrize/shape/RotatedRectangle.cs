// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
using geometrize.rasterizer;
using System;
using System.Collections.Generic;
using System.Xml.Schema;

namespace geometrize.shape
{
    public class RotatedRectangle : global::haxe.lang.HxObject, global::geometrize.shape.Shape
    {

        public RotatedRectangle(global::haxe.lang.EmptyObject empty)
        {
        }


        public RotatedRectangle(int xBound, int yBound)
        {
            global::geometrize.shape.RotatedRectangle.__hx_ctor_geometrize_shape_RotatedRectangle(this, xBound, yBound);
        }


        protected static void __hx_ctor_geometrize_shape_RotatedRectangle(global::geometrize.shape.RotatedRectangle __hx_this, int xBound, int yBound)
        {
            unchecked
            {
                __hx_this.x1 = global::Std.random(xBound);
                __hx_this.y1 = global::Std.random(yBound);
                int @value = __hx_this.x1 + global::Std.random(32) + 1;
                if (0 > xBound)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: min <= max");
                }

                __hx_this.x2 = (@value < 0) ? 0 : ((@value > xBound) ? xBound : @value);
                int value1 = __hx_this.y1 + global::Std.random(32) + 1;
                if (0 > yBound)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: min <= max");
                }

                __hx_this.y2 = (value1 < 0) ? 0 : ((value1 > yBound) ? yBound : value1);
                __hx_this.angle = (int)global::System.Math.Floor((double)(361 * global::HaxeMath.rand.NextDouble()));
                __hx_this.xBound = xBound;
                __hx_this.yBound = yBound;
            }
        }


        public int x1;

        public int y1;

        public int x2;

        public int y2;

        public int angle;

        public int xBound;

        public int yBound;

        public virtual IReadOnlyList<Scanline> rasterize()
        {
            unchecked
            {
                int xm1 = Math.Min(x1, x2);
                int xm2 = Math.Max(x1, x2);
                int ym1 = Math.Min(y1, y2);
                int ym2 = Math.Max(y1, y2);
                int cx = (xm1 + xm2) / 2;
                int cy = (ym1 + ym2) / 2;
                int ox1 = xm1 - cx;
                int ox2 = xm2 - cx;
                int oy1 = ym1 - cy;
                int oy2 = ym2 - cy;
                double rads = angle * Math.PI / 180.0;
                double c = Math.Cos((double)rads);
                double s = Math.Sin((double)rads);
                int ulx = (int)((ox1 * c) - (oy1 * s) + cx);
                int uly = (int)((ox1 * s) + (oy1 * c) + cy);
                int blx = (int)((ox1 * c) - (oy2 * s) + cx);
                int bly = (int)((ox1 * s) + (oy2 * c) + cy);
                int urx = (int)((ox2 * c) - (oy1 * s) + cx);
                int ury = (int)((ox2 * s) + (oy1 * c) + cy);
                int brx = (int)((ox2 * c) - (oy2 * s) + cx);
                int bry = (int)((ox2 * s) + (oy2 * c) + cy);

                var points = new Point[]
                {
                    new Point(ulx, uly),
                    new Point(urx, ury),
                    new Point(brx, bry),
                    new Point(blx, bly)
                };

                return Scanline.trim(Rasterizer.scanlinesForPolygon(points), xBound, yBound);
            }
        }


        public virtual void mutate()
        {
            unchecked
            {
                int r = global::Std.random(3);
                switch (r)
                {
                    case 0:
                        {
                            int @value = this.x1 + -16 + ((int)global::System.Math.Floor((double)(33 * global::HaxeMath.rand.NextDouble())));
                            int max = this.xBound - 1;
                            if (0 > max)
                            {
                                throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: min <= max");
                            }

                            this.x1 = (@value < 0) ? 0 : ((@value > max) ? max : @value);
                            int value1 = this.y1 + -16 + ((int)global::System.Math.Floor((double)(33 * global::HaxeMath.rand.NextDouble())));
                            int max1 = this.yBound - 1;
                            if (0 > max1)
                            {
                                throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: min <= max");
                            }

                            this.y1 = (value1 < 0) ? 0 : ((value1 > max1) ? max1 : value1);
                            break;
                        }


                    case 1:
                        {
                            int value2 = this.x2 + -16 + ((int)global::System.Math.Floor((double)(33 * global::HaxeMath.rand.NextDouble())));
                            int max2 = this.xBound - 1;
                            if (0 > max2)
                            {
                                throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: min <= max");
                            }

                            this.x2 = (value2 < 0) ? 0 : ((value2 > max2) ? max2 : value2);
                            int value3 = this.y2 + -16 + ((int)global::System.Math.Floor((double)(33 * global::HaxeMath.rand.NextDouble())));
                            int max3 = this.yBound - 1;
                            if (0 > max3)
                            {
                                throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: min <= max");
                            }

                            this.y2 = (value3 < 0) ? 0 : ((value3 > max3) ? max3 : value3);
                            break;
                        }


                    case 2:
                        {
                            int value4 = this.angle + -4 + ((int)global::System.Math.Floor((double)(9 * global::HaxeMath.rand.NextDouble())));
                            this.angle = (value4 < 0) ? 0 : ((value4 > 360) ? 360 : value4);
                            break;
                        }


                }

            }
        }


        public virtual global::geometrize.shape.Shape clone()
        {
            global::geometrize.shape.RotatedRectangle rectangle = new global::geometrize.shape.RotatedRectangle((int)this.xBound, (int)this.yBound);
            rectangle.x1 = this.x1;
            rectangle.y1 = this.y1;
            rectangle.x2 = this.x2;
            rectangle.y2 = this.y2;
            rectangle.angle = this.angle;
            return rectangle;
        }


        public virtual int getType()
        {
            unchecked
            {
                return (int)1;
            }
        }


        public virtual global::HaxeArray<double> getRawShapeData()
        {
            int first = this.x1;
            int second = this.x2;
            int first1 = this.y1;
            int second1 = this.y2;
            int first2 = this.x1;
            int second2 = this.x2;
            int first3 = this.y1;
            int second3 = this.y2;
            return new global::HaxeArray<double>(new double[] { (double)((first < second) ? first : second), (double)((first1 < second1) ? first1 : second1), (double)((first2 > second2) ? first2 : second2), (double)((first3 > second3) ? first3 : second3), (double)this.angle });
        }


        public virtual string getSvgShapeData()
        {
            unchecked
            {
                int first = this.x1;
                int second = this.x2;
                int xm1 = (first < second) ? first : second;
                int first1 = this.x1;
                int second1 = this.x2;
                int xm2 = (first1 > second1) ? first1 : second1;
                int first2 = this.y1;
                int second2 = this.y2;
                int ym1 = (first2 < second2) ? first2 : second2;
                int first3 = this.y1;
                int second3 = this.y2;
                int ym2 = (first3 > second3) ? first3 : second3;
                int cx = (xm1 + xm2) / 2;
                int cy = (ym1 + ym2) / 2;
                int ox1 = xm1 - cx;
                int ox2 = xm2 - cx;
                int oy1 = ym1 - cy;
                int oy2 = ym2 - cy;
                double rads = this.angle * global::HaxeMath.PI / 180.0;
                double c = global::System.Math.Cos((double)rads);
                double s = global::System.Math.Sin((double)rads);
                int ulx = (int)((ox1 * c) - (oy1 * s) + cx);
                int uly = (int)((ox1 * s) + (oy1 * c) + cy);
                int blx = (int)((ox1 * c) - (oy2 * s) + cx);
                int bly = (int)((ox1 * s) + (oy2 * c) + cy);
                int urx = (int)((ox2 * c) - (oy1 * s) + cx);
                int ury = (int)((ox2 * s) + (oy1 * c) + cy);
                int brx = (int)((ox2 * c) - (oy2 * s) + cx);
                int bry = (int)((ox2 * s) + (oy2 * c) + cy);
                global::HaxeArray<object> points = new global::HaxeArray<object>(new object[] { new global::haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { (double)ulx, (double)uly }), new global::haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { (double)urx, (double)ury }), new global::haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { (double)brx, (double)bry }), new global::haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { (double)blx, (double)bly }) });
                string s1 = "<polygon points=\"";
                {
                    int _g = 0;
                    int _g1 = points.length;
                    while (_g < _g1)
                    {
                        int i = _g++;
                        s1 = global::haxe.lang.Runtime.concat(s1, global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.toString((int)global::haxe.lang.Runtime.getField_f(points[i], "x", 120, true)), " "), global::haxe.lang.Runtime.toString((int)global::haxe.lang.Runtime.getField_f(points[i], "y", 121, true))));
                        if (i != (points.length - 1))
                        {
                            s1 = global::haxe.lang.Runtime.concat(s1, " ");
                        }

                    }

                }

                s1 = global::haxe.lang.Runtime.concat(s1, global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("\" ", global::geometrize.exporter.SvgExporter.SVG_STYLE_HOOK), "/>"));
                return s1;
            }
        }


        public global::HaxeArray<object> getCornerPoints()
        {
            unchecked
            {
                int first = this.x1;
                int second = this.x2;
                int xm1 = (first < second) ? first : second;
                int first1 = this.x1;
                int second1 = this.x2;
                int xm2 = (first1 > second1) ? first1 : second1;
                int first2 = this.y1;
                int second2 = this.y2;
                int ym1 = (first2 < second2) ? first2 : second2;
                int first3 = this.y1;
                int second3 = this.y2;
                int ym2 = (first3 > second3) ? first3 : second3;
                int cx = (xm1 + xm2) / 2;
                int cy = (ym1 + ym2) / 2;
                int ox1 = xm1 - cx;
                int ox2 = xm2 - cx;
                int oy1 = ym1 - cy;
                int oy2 = ym2 - cy;
                double rads = this.angle * global::HaxeMath.PI / 180.0;
                double c = global::System.Math.Cos((double)rads);
                double s = global::System.Math.Sin((double)rads);
                int ulx = (int)((ox1 * c) - (oy1 * s) + cx);
                int uly = (int)((ox1 * s) + (oy1 * c) + cy);
                int blx = (int)((ox1 * c) - (oy2 * s) + cx);
                int bly = (int)((ox1 * s) + (oy2 * c) + cy);
                int urx = (int)((ox2 * c) - (oy1 * s) + cx);
                int ury = (int)((ox2 * s) + (oy1 * c) + cy);
                int brx = (int)((ox2 * c) - (oy2 * s) + cx);
                int bry = (int)((ox2 * s) + (oy2 * c) + cy);
                return new global::HaxeArray<object>(new object[] { new global::haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { (double)ulx, (double)uly }), new global::haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { (double)urx, (double)ury }), new global::haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { (double)brx, (double)bry }), new global::haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { (double)blx, (double)bly }) });
            }
        }


        public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties)
        {
            unchecked
            {
                switch (hash)
                {
                    case 727238917:
                        {
                            this.yBound = (int)@value;
                            return @value;
                        }


                    case 1157459110:
                        {
                            this.xBound = (int)@value;
                            return @value;
                        }


                    case 585253843:
                        {
                            this.angle = (int)@value;
                            return @value;
                        }


                    case 27033:
                        {
                            this.y2 = (int)@value;
                            return @value;
                        }


                    case 26810:
                        {
                            this.x2 = (int)@value;
                            return @value;
                        }


                    case 27032:
                        {
                            this.y1 = (int)@value;
                            return @value;
                        }


                    case 26809:
                        {
                            this.x1 = (int)@value;
                            return @value;
                        }


                    default:
                        {
                            return base.__hx_setField_f(field, hash, @value, handleProperties);
                        }

                }

            }
        }


        public override object __hx_setField(string field, int hash, object @value, bool handleProperties)
        {
            unchecked
            {
                switch (hash)
                {
                    case 727238917:
                        {
                            this.yBound = (int)global::haxe.lang.Runtime.toInt(@value);
                            return @value;
                        }


                    case 1157459110:
                        {
                            this.xBound = (int)global::haxe.lang.Runtime.toInt(@value);
                            return @value;
                        }


                    case 585253843:
                        {
                            this.angle = (int)global::haxe.lang.Runtime.toInt(@value);
                            return @value;
                        }


                    case 27033:
                        {
                            this.y2 = (int)global::haxe.lang.Runtime.toInt(@value);
                            return @value;
                        }


                    case 26810:
                        {
                            this.x2 = (int)global::haxe.lang.Runtime.toInt(@value);
                            return @value;
                        }


                    case 27032:
                        {
                            this.y1 = (int)global::haxe.lang.Runtime.toInt(@value);
                            return @value;
                        }


                    case 26809:
                        {
                            this.x1 = (int)global::haxe.lang.Runtime.toInt(@value);
                            return @value;
                        }


                    default:
                        {
                            return base.__hx_setField(field, hash, @value, handleProperties);
                        }

                }

            }
        }


        public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties)
        {
            unchecked
            {
                switch (hash)
                {
                    case 1988045198:
                        {
                            return (global::haxe.lang.Function)new global::haxe.lang.Closure(this, "getCornerPoints", 1988045198);
                        }


                    case 1870080157:
                        {
                            return (global::haxe.lang.Function)new global::haxe.lang.Closure(this, "getSvgShapeData", 1870080157);
                        }


                    case 538995865:
                        {
                            return (global::haxe.lang.Function)new global::haxe.lang.Closure(this, "getRawShapeData", 538995865);
                        }


                    case 529244784:
                        {
                            return (global::haxe.lang.Function)new global::haxe.lang.Closure(this, "getType", 529244784);
                        }


                    case 1214452573:
                        {
                            return (global::haxe.lang.Function)new global::haxe.lang.Closure(this, "clone", 1214452573);
                        }


                    case 1069478790:
                        {
                            return (global::haxe.lang.Function)new global::haxe.lang.Closure(this, "mutate", 1069478790);
                        }


                    case 508245239:
                        {
                            return (global::haxe.lang.Function)new global::haxe.lang.Closure(this, "rasterize", 508245239);
                        }


                    case 727238917:
                        {
                            return this.yBound;
                        }


                    case 1157459110:
                        {
                            return this.xBound;
                        }


                    case 585253843:
                        {
                            return this.angle;
                        }


                    case 27033:
                        {
                            return this.y2;
                        }


                    case 26810:
                        {
                            return this.x2;
                        }


                    case 27032:
                        {
                            return this.y1;
                        }


                    case 26809:
                        {
                            return this.x1;
                        }


                    default:
                        {
                            return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
                        }

                }

            }
        }


        public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties)
        {
            unchecked
            {
                switch (hash)
                {
                    case 727238917:
                        {
                            return (double)this.yBound;
                        }


                    case 1157459110:
                        {
                            return (double)this.xBound;
                        }


                    case 585253843:
                        {
                            return (double)this.angle;
                        }


                    case 27033:
                        {
                            return (double)this.y2;
                        }


                    case 26810:
                        {
                            return (double)this.x2;
                        }


                    case 27032:
                        {
                            return (double)this.y1;
                        }


                    case 26809:
                        {
                            return (double)this.x1;
                        }


                    default:
                        {
                            return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
                        }

                }

            }
        }


        public override object __hx_invokeField(string field, int hash, object[] dynargs)
        {
            unchecked
            {
                switch (hash)
                {
                    case 1988045198:
                        {
                            return this.getCornerPoints();
                        }


                    case 1870080157:
                        {
                            return this.getSvgShapeData();
                        }


                    case 538995865:
                        {
                            return this.getRawShapeData();
                        }


                    case 529244784:
                        {
                            return this.getType();
                        }


                    case 1214452573:
                        {
                            return this.clone();
                        }


                    case 1069478790:
                        {
                            this.mutate();
                            break;
                        }


                    case 508245239:
                        {
                            return this.rasterize();
                        }


                    default:
                        {
                            return base.__hx_invokeField(field, hash, dynargs);
                        }

                }

                return null;
            }
        }


        public override void __hx_getFields(global::HaxeArray<string> baseArr)
        {
            baseArr.push("yBound");
            baseArr.push("xBound");
            baseArr.push("angle");
            baseArr.push("y2");
            baseArr.push("x2");
            baseArr.push("y1");
            baseArr.push("x1");
            base.__hx_getFields(baseArr);
        }


    }
}


