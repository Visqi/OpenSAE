// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
using geometrize.rasterizer;
using System;
using System.Collections.Generic;

namespace geometrize.shape
{
    public class RotatedEllipse : Shape
    {
        public RotatedEllipse(int xBound, int yBound)
        {
            x = Std.random(xBound);
            y = Std.random(yBound);
            rx = (Std.random(32) + 1);
            ry = (Std.random(32) + 1);
            angle = Std.random(360);
            this.xBound = xBound;
            this.yBound = yBound;
        }

        public int x;

        public int y;

        public int rx;

        public int ry;

        public int angle;

        public int xBound;

        public int yBound;

        public virtual IReadOnlyList<Scanline> rasterize()
        {
            int pointCount = 20;
            var points = new List<Point>();
            double rads = (this.angle * ((HaxeMath.PI / 180.0)));
            double c = Math.Cos(((double)(rads)));
            double s = Math.Sin(((double)(rads)));

            for (int i = 0; i < pointCount; i++)
            {
                double rot = (((360.0 / pointCount) * i) * ((HaxeMath.PI / 180.0)));
                double crx = (this.rx * Math.Cos(((double)(rot))));
                double cry = (this.ry * Math.Sin(((double)(rot))));
                int tx = ((int)((((crx * c) - (cry * s)) + this.x)));
                int ty = ((int)((((crx * s) + (cry * c)) + this.y)));
                points.Add(new Point(tx, ty));
            }

            return Scanline.trim(Rasterizer.scanlinesForPolygon(points), this.xBound, this.yBound);
        }


        public virtual void mutate()
        {
            unchecked
            {
                switch (HaxeMath.rand.Next(4))
                {
                    case 0:
                        x = Math.Clamp(x + -16 + HaxeMath.rand.Next(33), 0, xBound - 1);
                        y = Math.Clamp(y + -16 + HaxeMath.rand.Next(33), 0, xBound - 1);
                        break;

                    case 1:
                        rx = Math.Clamp(rx - 16 + HaxeMath.rand.Next(33), 1, xBound - 1);
                        break;

                    case 2:
                        ry = Math.Clamp(ry - 16 + HaxeMath.rand.Next(33), 1, xBound - 1);
                        break;

                    case 3:
                        {
                            int value4 = (this.angle + ((-4 + ((int)(Math.Floor(((double)((9 * HaxeMath.rand.NextDouble())))))))));
                            this.angle = (((value4 < 0)) ? (0) : ((((value4 > 360)) ? (360) : (value4))));
                            break;
                        }
                }
            }
        }


        public virtual Shape clone()
        {
            return new RotatedEllipse(xBound, yBound)
            {
                x = x,
                y = y,
                rx = rx,
                ry = ry,
                angle = angle
            };
        }


        public virtual int getType() => 4;


        public virtual double[] getRawShapeData()
        {
            return new double[]
            {
                x, y, rx, ry, angle
            };
        }
    }
}


