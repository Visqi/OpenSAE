// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace geometrize {
	public class Core : global::haxe.lang.HxObject {
		
		public Core(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Core() {
			global::geometrize.Core.__hx_ctor_geometrize_Core(this);
		}
		
		
		protected static void __hx_ctor_geometrize_Core(global::geometrize.Core __hx_this) {
		}
		
		
		public static int computeColor(global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::HaxeArray<object> lines, int alpha) {
			unchecked {
				if (( target == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: target != null")) );
				}
				
				if (( current == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: current != null")) );
				}
				
				if (( lines == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: lines != null")) );
				}
				
				if (( alpha < 0 )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: alpha >= 0")) );
				}
				
				int totalRed = 0;
				int totalGreen = 0;
				int totalBlue = 0;
				int count = 0;
				double f = ( ((double) (65535) ) / alpha );
				int a = ((int) (f) );
				{
					int _g = 0;
					while (( _g < lines.length )) {
						global::geometrize.rasterizer.Scanline line = ((global::geometrize.rasterizer.Scanline) (lines[_g]) );
						 ++ _g;
						int y = line.y;
						{
							int _g1 = line.x1;
							int _g2 = ( line.x2 + 1 );
							while (( _g1 < _g2 )) {
								int x = _g1++;
								int t = ((int[]) (target.data) )[( ( target.width * y ) + x )];
								int c = ((int[]) (current.data) )[( ( current.width * y ) + x )];
								totalRed += ( ( (( (( ( ((int) (t) ) >> 24 ) & 255 )) - (( ( ((int) (c) ) >> 24 ) & 255 )) )) * a ) + ( (( ( ((int) (c) ) >> 24 ) & 255 )) * 257 ) );
								totalGreen += ( ( (( (( ( ((int) (t) ) >> 16 ) & 255 )) - (( ( ((int) (c) ) >> 16 ) & 255 )) )) * a ) + ( (( ( ((int) (c) ) >> 16 ) & 255 )) * 257 ) );
								totalBlue += ( ( (( (( ( ((int) (t) ) >> 8 ) & 255 )) - (( ( ((int) (c) ) >> 8 ) & 255 )) )) * a ) + ( (( ( ((int) (c) ) >> 8 ) & 255 )) * 257 ) );
								 ++ count;
							}
							
						}
						
					}
					
				}
				
				if (( count == 0 )) {
					return 0;
				}
				
				int @value = ( ( totalRed / count ) >> 8 );
				int r = ( (( @value < 0 )) ? (0) : (( (( @value > 255 )) ? (255) : (@value) )) );
				int value1 = ( ( totalGreen / count ) >> 8 );
				int g = ( (( value1 < 0 )) ? (0) : (( (( value1 > 255 )) ? (255) : (value1) )) );
				int value2 = ( ( totalBlue / count ) >> 8 );
				int b = ( (( value2 < 0 )) ? (0) : (( (( value2 > 255 )) ? (255) : (value2) )) );
				return ((int) (( ( ( (( (( (( r < 0 )) ? (0) : (( (( r > 255 )) ? (255) : (r) )) )) << 24 )) + (( (( (( g < 0 )) ? (0) : (( (( g > 255 )) ? (255) : (g) )) )) << 16 )) ) + (( (( (( b < 0 )) ? (0) : (( (( b > 255 )) ? (255) : (b) )) )) << 8 )) ) + (( (( alpha < 0 )) ? (0) : (( (( alpha > 255 )) ? (255) : (alpha) )) )) )) );
			}
		}
		
		
		public static double differenceFull(global::geometrize.bitmap.Bitmap first, global::geometrize.bitmap.Bitmap second) {
			unchecked {
				if (( first == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: first != null")) );
				}
				
				if (( second == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: second != null")) );
				}
				
				{
					int actual = first.width;
					int expected = second.width;
					if (( actual != expected )) {
						throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("FAIL: values are not equal (expected: ", global::haxe.lang.Runtime.toString(expected)), ", actual: "), global::haxe.lang.Runtime.toString(actual)), ")"))) );
					}
					
				}
				
				{
					int actual1 = first.height;
					int expected1 = second.height;
					if (( actual1 != expected1 )) {
						throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("FAIL: values are not equal (expected: ", global::haxe.lang.Runtime.toString(expected1)), ", actual: "), global::haxe.lang.Runtime.toString(actual1)), ")"))) );
					}
					
				}
				
				double total = ((double) (0) );
				int width = first.width;
				int height = first.height;
				{
					int _g = 0;
					int _g1 = height;
					while (( _g < _g1 )) {
						int y = _g++;
						{
							int _g2 = 0;
							int _g3 = width;
							while (( _g2 < _g3 )) {
								int x = _g2++;
								int f = ((int[]) (first.data) )[( ( first.width * y ) + x )];
								int s = ((int[]) (second.data) )[( ( second.width * y ) + x )];
								int dr = ( (( ( ((int) (f) ) >> 24 ) & 255 )) - (( ( ((int) (s) ) >> 24 ) & 255 )) );
								int dg = ( (( ( ((int) (f) ) >> 16 ) & 255 )) - (( ( ((int) (s) ) >> 16 ) & 255 )) );
								int db = ( (( ( ((int) (f) ) >> 8 ) & 255 )) - (( ( ((int) (s) ) >> 8 ) & 255 )) );
								int da = ( (( ((int) (f) ) & 255 )) - (( ((int) (s) ) & 255 )) );
								total += ((double) (( ( ( ( dr * dr ) + ( dg * dg ) ) + ( db * db ) ) + ( da * da ) )) );
							}
							
						}
						
					}
					
				}
				
				return ( global::System.Math.Sqrt(((double) (( total / (( ( width * height ) * 4.0 )) )) )) / 255 );
			}
		}
		
		
		public static double differencePartial(global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap before, global::geometrize.bitmap.Bitmap after, double score, global::HaxeArray<object> lines) {
			unchecked {
				if (( target == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: target != null")) );
				}
				
				if (( before == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: before != null")) );
				}
				
				if (( after == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: after != null")) );
				}
				
				if (( lines == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: lines != null")) );
				}
				
				int width = target.width;
				int height = target.height;
				int rgbaCount = ( ( width * height ) * 4 );
				double total = ( global::System.Math.Pow(((double) (( score * 255 )) ), ((double) (2) )) * rgbaCount );
				{
					int _g = 0;
					while (( _g < lines.length )) {
						global::geometrize.rasterizer.Scanline line = ((global::geometrize.rasterizer.Scanline) (lines[_g]) );
						 ++ _g;
						int y = line.y;
						{
							int _g1 = line.x1;
							int _g2 = ( line.x2 + 1 );
							while (( _g1 < _g2 )) {
								int x = _g1++;
								int t = ((int[]) (target.data) )[( ( target.width * y ) + x )];
								int b = ((int[]) (before.data) )[( ( before.width * y ) + x )];
								int a = ((int[]) (after.data) )[( ( after.width * y ) + x )];
								int dtbr = ( (( ( ((int) (t) ) >> 24 ) & 255 )) - (( ( ((int) (b) ) >> 24 ) & 255 )) );
								int dtbg = ( (( ( ((int) (t) ) >> 16 ) & 255 )) - (( ( ((int) (b) ) >> 16 ) & 255 )) );
								int dtbb = ( (( ( ((int) (t) ) >> 8 ) & 255 )) - (( ( ((int) (b) ) >> 8 ) & 255 )) );
								int dtba = ( (( ((int) (t) ) & 255 )) - (( ((int) (b) ) & 255 )) );
								int dtar = ( (( ( ((int) (t) ) >> 24 ) & 255 )) - (( ( ((int) (a) ) >> 24 ) & 255 )) );
								int dtag = ( (( ( ((int) (t) ) >> 16 ) & 255 )) - (( ( ((int) (a) ) >> 16 ) & 255 )) );
								int dtab = ( (( ( ((int) (t) ) >> 8 ) & 255 )) - (( ( ((int) (a) ) >> 8 ) & 255 )) );
								int dtaa = ( (( ((int) (t) ) & 255 )) - (( ((int) (a) ) & 255 )) );
								total -= ((double) (( ( ( ( dtbr * dtbr ) + ( dtbg * dtbg ) ) + ( dtbb * dtbb ) ) + ( dtba * dtba ) )) );
								total += ((double) (( ( ( ( dtar * dtar ) + ( dtag * dtag ) ) + ( dtab * dtab ) ) + ( dtaa * dtaa ) )) );
							}
							
						}
						
					}
					
				}
				
				return ( global::System.Math.Sqrt(((double) (( total / rgbaCount )) )) / 255 );
			}
		}
		
		
		public static global::geometrize.State bestRandomState(global::HaxeArray<int> shapes, int alpha, int n, global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::geometrize.bitmap.Bitmap buffer, double lastScore) {
			double bestEnergy = ((double) (0) );
			global::geometrize.State bestState = null;
			{
				int _g = 0;
				int _g1 = n;
				while (( _g < _g1 )) {
					int i = _g++;
					global::geometrize.State state = new global::geometrize.State(((global::geometrize.shape.Shape) (global::geometrize.shape.ShapeFactory.randomShapeOf(shapes, current.width, current.height)) ), ((int) (alpha) ), ((global::geometrize.bitmap.Bitmap) (target) ), ((global::geometrize.bitmap.Bitmap) (current) ), ((global::geometrize.bitmap.Bitmap) (buffer) ));
					double energy = state.energy(lastScore);
					if (( ( i == 0 ) || ( energy < bestEnergy ) )) {
						bestEnergy = energy;
						bestState = state;
					}
					
				}
				
			}
			
			return bestState;
		}
		
		
		public static global::geometrize.State bestHillClimbState(global::HaxeArray<int> shapes, int alpha, int n, int age, global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::geometrize.bitmap.Bitmap buffer, double lastScore) {
			global::geometrize.State state = global::geometrize.Core.bestRandomState(shapes, alpha, n, target, current, buffer, lastScore);
			state = global::geometrize.Core.hillClimb(state, age, lastScore);
			return state;
		}
		
		
		public static global::geometrize.State hillClimb(global::geometrize.State state, int maxAge, double lastScore) {
			unchecked {
				if (( state == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: state != null")) );
				}
				
				if (( maxAge < 0 )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: maxAge >= 0")) );
				}
				
				global::geometrize.State state1 = state.clone();
				global::geometrize.State bestState = state1.clone();
				double bestEnergy = state1.energy(lastScore);
				int age = 0;
				while (( age < maxAge )) {
					global::geometrize.State undo = state1.mutate();
					double energy = state1.energy(lastScore);
					if (( energy >= bestEnergy )) {
						state1 = undo;
					}
					else {
						bestEnergy = energy;
						bestState = state1.clone();
						age = -1;
					}
					
					 ++ age;
				}
				
				return bestState;
			}
		}
		
		
		public static double energy(global::geometrize.shape.Shape shape, int alpha, global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::geometrize.bitmap.Bitmap buffer, double score) {
			if (( shape == null )) {
				throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: shape != null")) );
			}
			
			if (( target == null )) {
				throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: target != null")) );
			}
			
			if (( current == null )) {
				throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: current != null")) );
			}
			
			if (( buffer == null )) {
				throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: buffer != null")) );
			}
			
			global::HaxeArray<object> lines = shape.rasterize();
			int color = global::geometrize.Core.computeColor(target, current, lines, alpha);
			global::geometrize.rasterizer.Rasterizer.copyLines(buffer, current, lines);
			global::geometrize.rasterizer.Rasterizer.drawLines(buffer, color, lines);
			return global::geometrize.Core.differencePartial(target, current, buffer, score, lines);
		}
		
		
	}
}


