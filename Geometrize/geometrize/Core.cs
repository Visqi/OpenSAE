// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
using geometrize.rasterizer;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace geometrize
{
    public class Core : global::haxe.lang.HxObject
    {

        public Core(global::haxe.lang.EmptyObject empty)
        {
        }


        public Core()
        {
            global::geometrize.Core.__hx_ctor_geometrize_Core(this);
        }


        protected static void __hx_ctor_geometrize_Core(global::geometrize.Core __hx_this)
        {
        }


        public static int computeColor(global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, IEnumerable<Scanline> lines, int alpha)
        {
            unchecked
            {
                if (target == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: target != null");
                }

                if (current == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: current != null");
                }

                if (lines == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: lines != null");
                }

                if (alpha < 0)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: alpha >= 0");
                }

                int totalRed = 0;
                int totalGreen = 0;
                int totalBlue = 0;
                int count = 0;
                int a = (int)(double)(65535 / alpha);

                foreach (var line in lines)
                {
                    int y = line.y;

                    for (int x = line.x1; x < line.x2 + 1; x++)
                    {
                        int t = target.data[(target.width * y) + x];
                        int c = current.data[(current.width * y) + x];
                        totalRed += ((((t >> 24) & 255) - ((c >> 24) & 255)) * a) + (((c >> 24) & 255) * 257);
                        totalGreen += ((((t >> 16) & 255) - ((c >> 16) & 255)) * a) + (((c >> 16) & 255) * 257);
                        totalBlue += ((((t >> 8) & 255) - ((c >> 8) & 255)) * a) + (((c >> 8) & 255) * 257);
                        ++count;
                    }
                }

                if (count == 0)
                {
                    return 0;
                }

                int @value = (totalRed / count) >> 8;
                int r = (@value < 0) ? 0 : ((@value > 255) ? 255 : @value);
                int value1 = (totalGreen / count) >> 8;
                int g = (value1 < 0) ? 0 : ((value1 > 255) ? 255 : value1);
                int value2 = (totalBlue / count) >> 8;
                int b = (value2 < 0) ? 0 : ((value2 > 255) ? 255 : value2);
                return (((r < 0) ? 0 : ((r > 255) ? 255 : r)) << 24) + (((g < 0) ? 0 : ((g > 255) ? 255 : g)) << 16) + (((b < 0) ? 0 : ((b > 255) ? 255 : b)) << 8) + ((alpha < 0) ? 0 : ((alpha > 255) ? 255 : alpha));
            }
        }


        public static double differenceFull(global::geometrize.bitmap.Bitmap first, global::geometrize.bitmap.Bitmap second)
        {
            unchecked
            {
                if (first == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: first != null");
                }

                if (second == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: second != null");
                }

                {
                    int actual = first.width;
                    int expected = second.width;
                    if (actual != expected)
                    {
                        throw (global::System.Exception)global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("FAIL: values are not equal (expected: ", global::haxe.lang.Runtime.toString(expected)), ", actual: "), global::haxe.lang.Runtime.toString(actual)), ")"));
                    }

                }

                {
                    int actual1 = first.height;
                    int expected1 = second.height;
                    if (actual1 != expected1)
                    {
                        throw (global::System.Exception)global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("FAIL: values are not equal (expected: ", global::haxe.lang.Runtime.toString(expected1)), ", actual: "), global::haxe.lang.Runtime.toString(actual1)), ")"));
                    }

                }

                double total = 0;
                int width = first.width;
                int height = first.height;
                {
                    int _g = 0;
                    int _g1 = height;
                    while (_g < _g1)
                    {
                        int y = _g++;
                        {
                            int _g2 = 0;
                            int _g3 = width;
                            while (_g2 < _g3)
                            {
                                int x = _g2++;
                                int f = first.data[(first.width * y) + x];
                                int s = second.data[(second.width * y) + x];
                                int dr = ((f >> 24) & 255) - ((s >> 24) & 255);
                                int dg = ((f >> 16) & 255) - ((s >> 16) & 255);
                                int db = ((f >> 8) & 255) - ((s >> 8) & 255);
                                int da = (f & 255) - (s & 255);
                                total += (dr * dr) + (dg * dg) + (db * db) + (da * da);
                            }

                        }

                    }

                }

                return global::System.Math.Sqrt(total / (width * height * 4.0)) / 255;
            }
        }


        public static double differencePartial(bitmap.Bitmap target, bitmap.Bitmap before, bitmap.Bitmap after, double score, IEnumerable<Scanline> lines)
        {
            unchecked
            {
                if (target == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: target != null");
                }

                if (before == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: before != null");
                }

                if (after == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: after != null");
                }

                if (lines == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: lines != null");
                }

                int width = target.width;
                int height = target.height;
                int rgbaCount = width * height * 4;
                double total = global::System.Math.Pow(score * 255, 2) * rgbaCount;

                foreach (var line in lines)
                {
                    int y = line.y;
                    {
                        int _g1 = line.x1;
                        int _g2 = line.x2 + 1;
                        while (_g1 < _g2)
                        {
                            int x = _g1++;
                            int t = target.data[(target.width * y) + x];
                            int b = before.data[(before.width * y) + x];
                            int a = after.data[(after.width * y) + x];
                            int dtbr = ((t >> 24) & 255) - ((b >> 24) & 255);
                            int dtbg = ((t >> 16) & 255) - ((b >> 16) & 255);
                            int dtbb = ((t >> 8) & 255) - ((b >> 8) & 255);
                            int dtba = (t & 255) - (b & 255);
                            int dtar = ((t >> 24) & 255) - ((a >> 24) & 255);
                            int dtag = ((t >> 16) & 255) - ((a >> 16) & 255);
                            int dtab = ((t >> 8) & 255) - ((a >> 8) & 255);
                            int dtaa = (t & 255) - (a & 255);
                            total -= (dtbr * dtbr) + (dtbg * dtbg) + (dtbb * dtbb) + (dtba * dtba);
                            total += (dtar * dtar) + (dtag * dtag) + (dtab * dtab) + (dtaa * dtaa);
                        }

                    }
                }

                return global::System.Math.Sqrt(total / rgbaCount) / 255;
            }
        }


        public static State bestRandomState(global::HaxeArray<int> shapes, int alpha, int n, global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::geometrize.bitmap.Bitmap buffer, double lastScore, SymbolShapeOptions symbolOptions)
        {
            object lockObj = new object();

            double bestEnergy = 0;
            State bestState = null;

            Parallel.For(0, n, (i) =>
            {
                State state = new State(shape.ShapeFactory.randomShapeOf(shapes, current.width, current.height, symbolOptions), alpha, target, current, buffer);
                double energy = state.energy(lastScore);

                lock (lockObj)
                {
                    if ((i == 0) || (energy < bestEnergy))
                    {
                        bestEnergy = energy;
                        bestState = state;
                    }
                }
            });

            return bestState;
        }


        public static State bestHillClimbState(global::HaxeArray<int> shapes, int alpha, int n, int age, global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::geometrize.bitmap.Bitmap buffer, double lastScore, SymbolShapeOptions symbolOptions)
        {
            State state = global::geometrize.Core.bestRandomState(shapes, alpha, n, target, current, buffer, lastScore, symbolOptions);
            System.Diagnostics.Debug.WriteLine("Best random state:     {0}", state.energy(lastScore));
            state = global::geometrize.Core.hillClimb(state, age, lastScore);
            System.Diagnostics.Debug.WriteLine("Best hill climb state: {0}", state.energy(lastScore));
            return state;
        }


        public static State hillClimb(State state, int maxAge, double lastScore)
        {
            unchecked
            {
                if (state == null)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: state != null");
                }

                if (maxAge < 0)
                {
                    throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: maxAge >= 0");
                }

                state = state.clone();
                State bestState = state.clone();
                double bestEnergy = state.energy(lastScore);

                int age = 0;
                
                while (age < maxAge)
                {
                    State undo = state.mutate();
                    double energy = state.energy(lastScore);
                    if (energy >= bestEnergy)
                    {
                        state = undo;
                    }
                    else
                    {
                        bestEnergy = energy;
                        bestState = state.clone();
                        age = -1;
                    }

                    age++;
                }

                return bestState;
            }
        }


        public static double energy(shape.Shape shape, int alpha, bitmap.Bitmap target, bitmap.Bitmap current, bitmap.Bitmap buffer, double score)
        {
            if (shape == null)
            {
                throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: shape != null");
            }

            if (target == null)
            {
                throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: target != null");
            }

            if (current == null)
            {
                throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: current != null");
            }

            if (buffer == null)
            {
                throw (global::System.Exception)global::haxe.Exception.thrown("FAIL: buffer != null");
            }

            var lines = shape.rasterize();
            int color = computeColor(target, current, lines, alpha);
            Rasterizer.copyLines(buffer, current, lines);
            Rasterizer.drawLines(buffer, color, lines);
            return differencePartial(target, current, buffer, score, lines);
        }


    }
}


