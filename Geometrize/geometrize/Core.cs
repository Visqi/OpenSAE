// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
using System.Threading.Tasks;

namespace geometrize
{
    public class Core : global::haxe.lang.HxObject
    {

        public Core(global::haxe.lang.EmptyObject empty)
        {
        }


        public Core()
        {
            global::geometrize.Core.__hx_ctor_geometrize_Core(this);
        }


        protected static void __hx_ctor_geometrize_Core(global::geometrize.Core __hx_this)
        {
        }


        public static int computeColor(global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::HaxeArray<object> lines, int alpha)
        {
            unchecked
            {
                if ((target == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: target != null")));
                }

                if ((current == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: current != null")));
                }

                if ((lines == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: lines != null")));
                }

                if ((alpha < 0))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: alpha >= 0")));
                }

                int totalRed = 0;
                int totalGreen = 0;
                int totalBlue = 0;
                int count = 0;
                double f = (65535 / alpha);
                int a = ((int)(f));
                {
                    int _g = 0;
                    while ((_g < lines.length))
                    {
                        global::geometrize.rasterizer.Scanline line = ((global::geometrize.rasterizer.Scanline)(lines[_g]));
                        ++_g;
                        int y = line.y;
                        {
                            int _g1 = line.x1;
                            int _g2 = (line.x2 + 1);
                            while ((_g1 < _g2))
                            {
                                int x = _g1++;
                                int t = ((int[])(target.data))[((target.width * y) + x)];
                                int c = ((int[])(current.data))[((current.width * y) + x)];
                                totalRed += (((((((t >> 24) & 255)) - (((c >> 24) & 255)))) * a) + ((((c >> 24) & 255)) * 257));
                                totalGreen += (((((((t >> 16) & 255)) - (((c >> 16) & 255)))) * a) + ((((c >> 16) & 255)) * 257));
                                totalBlue += (((((((t >> 8) & 255)) - (((c >> 8) & 255)))) * a) + ((((c >> 8) & 255)) * 257));
                                ++count;
                            }

                        }

                    }

                }

                if ((count == 0))
                {
                    return 0;
                }

                int @value = ((totalRed / count) >> 8);
                int r = (((@value < 0)) ? (0) : ((((@value > 255)) ? (255) : (@value))));
                int value1 = ((totalGreen / count) >> 8);
                int g = (((value1 < 0)) ? (0) : ((((value1 > 255)) ? (255) : (value1))));
                int value2 = ((totalBlue / count) >> 8);
                int b = (((value2 < 0)) ? (0) : ((((value2 > 255)) ? (255) : (value2))));
                return (((((((((r < 0)) ? (0) : ((((r > 255)) ? (255) : (r))))) << 24)) + ((((((g < 0)) ? (0) : ((((g > 255)) ? (255) : (g))))) << 16))) + ((((((b < 0)) ? (0) : ((((b > 255)) ? (255) : (b))))) << 8))) + ((((alpha < 0)) ? (0) : ((((alpha > 255)) ? (255) : (alpha))))));
            }
        }


        public static double differenceFull(global::geometrize.bitmap.Bitmap first, global::geometrize.bitmap.Bitmap second)
        {
            unchecked
            {
                if ((first == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: first != null")));
                }

                if ((second == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: second != null")));
                }

                {
                    int actual = first.width;
                    int expected = second.width;
                    if ((actual != expected))
                    {
                        throw ((global::System.Exception)(global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("FAIL: values are not equal (expected: ", global::haxe.lang.Runtime.toString(expected)), ", actual: "), global::haxe.lang.Runtime.toString(actual)), ")"))));
                    }

                }

                {
                    int actual1 = first.height;
                    int expected1 = second.height;
                    if ((actual1 != expected1))
                    {
                        throw ((global::System.Exception)(global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("FAIL: values are not equal (expected: ", global::haxe.lang.Runtime.toString(expected1)), ", actual: "), global::haxe.lang.Runtime.toString(actual1)), ")"))));
                    }

                }

                double total = 0;
                int width = first.width;
                int height = first.height;
                {
                    int _g = 0;
                    int _g1 = height;
                    while ((_g < _g1))
                    {
                        int y = _g++;
                        {
                            int _g2 = 0;
                            int _g3 = width;
                            while ((_g2 < _g3))
                            {
                                int x = _g2++;
                                int f = ((int[])(first.data))[((first.width * y) + x)];
                                int s = ((int[])(second.data))[((second.width * y) + x)];
                                int dr = ((((f >> 24) & 255)) - (((s >> 24) & 255)));
                                int dg = ((((f >> 16) & 255)) - (((s >> 16) & 255)));
                                int db = ((((f >> 8) & 255)) - (((s >> 8) & 255)));
                                int da = (((f & 255)) - ((s & 255)));
                                total += ((((dr * dr) + (dg * dg)) + (db * db)) + (da * da));
                            }

                        }

                    }

                }

                return (global::System.Math.Sqrt((total / (((width * height) * 4.0)))) / 255);
            }
        }


        public static double differencePartial(global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap before, global::geometrize.bitmap.Bitmap after, double score, global::HaxeArray<object> lines)
        {
            unchecked
            {
                if ((target == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: target != null")));
                }

                if ((before == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: before != null")));
                }

                if ((after == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: after != null")));
                }

                if ((lines == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: lines != null")));
                }

                int width = target.width;
                int height = target.height;
                int rgbaCount = ((width * height) * 4);
                double total = (global::System.Math.Pow((score * 255), 2) * rgbaCount);
                {
                    int _g = 0;
                    while ((_g < lines.length))
                    {
                        global::geometrize.rasterizer.Scanline line = ((global::geometrize.rasterizer.Scanline)(lines[_g]));
                        ++_g;
                        int y = line.y;
                        {
                            int _g1 = line.x1;
                            int _g2 = (line.x2 + 1);
                            while ((_g1 < _g2))
                            {
                                int x = _g1++;
                                int t = ((int[])(target.data))[((target.width * y) + x)];
                                int b = ((int[])(before.data))[((before.width * y) + x)];
                                int a = ((int[])(after.data))[((after.width * y) + x)];
                                int dtbr = ((((t >> 24) & 255)) - (((b >> 24) & 255)));
                                int dtbg = ((((t >> 16) & 255)) - (((b >> 16) & 255)));
                                int dtbb = ((((t >> 8) & 255)) - (((b >> 8) & 255)));
                                int dtba = (((t & 255)) - ((b & 255)));
                                int dtar = ((((t >> 24) & 255)) - (((a >> 24) & 255)));
                                int dtag = ((((t >> 16) & 255)) - (((a >> 16) & 255)));
                                int dtab = ((((t >> 8) & 255)) - (((a >> 8) & 255)));
                                int dtaa = (((t & 255)) - ((a & 255)));
                                total -= ((((dtbr * dtbr) + (dtbg * dtbg)) + (dtbb * dtbb)) + (dtba * dtba));
                                total += ((((dtar * dtar) + (dtag * dtag)) + (dtab * dtab)) + (dtaa * dtaa));
                            }

                        }

                    }

                }

                return (global::System.Math.Sqrt((total / rgbaCount)) / 255);
            }
        }


        public static State bestRandomState(global::HaxeArray<int> shapes, int alpha, int n, global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::geometrize.bitmap.Bitmap buffer, double lastScore)
        {
            object lockObj = new object();

            double bestEnergy = 0;
            State bestState = null;

            Parallel.For(0, n, (i) =>
            {
                State state = new State(shape.ShapeFactory.randomShapeOf(shapes, current.width, current.height), alpha, target, current, buffer);
                double energy = state.energy(lastScore);

                lock (lockObj)
                {
                    if ((i == 0) || (energy < bestEnergy))
                    {
                        bestEnergy = energy;
                        bestState = state;
                    }
					
				}
            });

            return bestState;
        }


        public static State bestHillClimbState(global::HaxeArray<int> shapes, int alpha, int n, int age, global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::geometrize.bitmap.Bitmap buffer, double lastScore)
        {
            State state = global::geometrize.Core.bestRandomState(shapes, alpha, n, target, current, buffer, lastScore);
            state = global::geometrize.Core.hillClimb(state, age, lastScore);
            return state;
        }


        public static State hillClimb(State state, int maxAge, double lastScore)
        {
            unchecked
            {
                if ((state == null))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: state != null")));
                }

                if ((maxAge < 0))
                {
                    throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: maxAge >= 0")));
                }

                State state1 = state.clone();
                State bestState = state1.clone();
                double bestEnergy = state1.energy(lastScore);

                for (int age = 0; age < maxAge; age++)
                {
                    State undo = state1.mutate();
                    double energy = state1.energy(lastScore);
                    if ((energy >= bestEnergy))
                    {
                        state1 = undo;
                    }
                    else
                    {
                        bestEnergy = energy;
                        bestState = state1.clone();
                        age = -1;
                    }
					
					 ++ age;
                }

                return bestState;
            }
        }


        public static double energy(global::geometrize.shape.Shape shape, int alpha, global::geometrize.bitmap.Bitmap target, global::geometrize.bitmap.Bitmap current, global::geometrize.bitmap.Bitmap buffer, double score)
        {
            if ((shape == null))
            {
                throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: shape != null")));
            }

            if ((target == null))
            {
                throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: target != null")));
            }

            if ((current == null))
            {
                throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: current != null")));
            }

            if ((buffer == null))
            {
                throw ((global::System.Exception)(global::haxe.Exception.thrown("FAIL: buffer != null")));
            }

            global::HaxeArray<object> lines = shape.rasterize();
            int color = global::geometrize.Core.computeColor(target, current, lines, alpha);
            global::geometrize.rasterizer.Rasterizer.copyLines(buffer, current, lines);
            global::geometrize.rasterizer.Rasterizer.drawLines(buffer, color, lines);
            return global::geometrize.Core.differencePartial(target, current, buffer, score, lines);
        }


    }
}


