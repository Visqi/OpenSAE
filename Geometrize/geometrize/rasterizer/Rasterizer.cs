// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace geometrize.rasterizer {
	public class Rasterizer : global::haxe.lang.HxObject {
		
		public Rasterizer(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Rasterizer() {
			global::geometrize.rasterizer.Rasterizer.__hx_ctor_geometrize_rasterizer_Rasterizer(this);
		}
		
		
		protected static void __hx_ctor_geometrize_rasterizer_Rasterizer(global::geometrize.rasterizer.Rasterizer __hx_this) {
		}
		
		
		public static void drawLines(global::geometrize.bitmap.Bitmap image, int c, global::HaxeArray<object> lines) {
			unchecked {
				if (( image == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: image != null")) );
				}
				
				if (( lines == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: lines != null")) );
				}
				
				int sr = ( ( ((int) (c) ) >> 24 ) & 255 );
				sr |= ( sr << 8 );
				sr *= ( ((int) (c) ) & 255 );
				sr = ( sr / 255 );
				int sg = ( ( ((int) (c) ) >> 16 ) & 255 );
				sg |= ( sg << 8 );
				sg *= ( ((int) (c) ) & 255 );
				sg = ( sg / 255 );
				int sb = ( ( ((int) (c) ) >> 8 ) & 255 );
				sb |= ( sb << 8 );
				sb *= ( ((int) (c) ) & 255 );
				sb = ( sb / 255 );
				int sa = ( ((int) (c) ) & 255 );
				sa |= ( sa << 8 );
				{
					int _g = 0;
					while (( _g < lines.length )) {
						global::geometrize.rasterizer.Scanline line = ((global::geometrize.rasterizer.Scanline) (lines[_g]) );
						 ++ _g;
						int y = line.y;
						int ma = 65535;
						int m = 65535;
						double @as = ( (( m - ( sa * (( ((double) (ma) ) / m )) ) )) * 257 );
						int a = ((int) (@as) );
						{
							int _g1 = line.x1;
							int _g2 = ( line.x2 + 1 );
							while (( _g1 < _g2 )) {
								int x = _g1++;
								int d = ((int[]) (image.data) )[( ( image.width * y ) + x )];
								uint dr = ((uint) (( ( ((int) (d) ) >> 24 ) & 255 )) );
								uint dg = ((uint) (( ( ((int) (d) ) >> 16 ) & 255 )) );
								uint db = ((uint) (( ( ((int) (d) ) >> 8 ) & 255 )) );
								uint da = ((uint) (( ((int) (d) ) & 255 )) );
								uint r = ((uint) (( ((int) (((double) (( ((double) ((((uint) (( ((uint) (( dr * a )) ) + ( sr * ma ) )) ))) ) / m )) )) ) >> 8 )) );
								uint g = ((uint) (( ((int) (((double) (( ((double) ((((uint) (( ((uint) (( dg * a )) ) + ( sg * ma ) )) ))) ) / m )) )) ) >> 8 )) );
								uint b = ((uint) (( ((int) (((double) (( ((double) ((((uint) (( ((uint) (( db * a )) ) + ( sb * ma ) )) ))) ) / m )) )) ) >> 8 )) );
								uint a1 = ((uint) (( ((int) (((double) (( ((double) ((((uint) (( ((uint) (( da * a )) ) + ( sa * ma ) )) ))) ) / m )) )) ) >> 8 )) );
								((int[]) (image.data) )[( ( image.width * y ) + x )] = ((int) (( ( ( (( (( (( r < 0 )) ? (0) : (( (( r > 255 )) ? (255) : (((int) (r) )) )) )) << 24 )) + (( (( (( g < 0 )) ? (0) : (( (( g > 255 )) ? (255) : (((int) (g) )) )) )) << 16 )) ) + (( (( (( b < 0 )) ? (0) : (( (( b > 255 )) ? (255) : (((int) (b) )) )) )) << 8 )) ) + (( (( a1 < 0 )) ? (0) : (( (( a1 > 255 )) ? (255) : (((int) (a1) )) )) )) )) );
							}
							
						}
						
					}
					
				}
				
			}
		}
		
		
		public static void copyLines(global::geometrize.bitmap.Bitmap destination, global::geometrize.bitmap.Bitmap source, global::HaxeArray<object> lines) {
			unchecked {
				if (( destination == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: destination != null")) );
				}
				
				if (( source == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: source != null")) );
				}
				
				if (( lines == null )) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown("FAIL: lines != null")) );
				}
				
				{
					int _g = 0;
					while (( _g < lines.length )) {
						global::geometrize.rasterizer.Scanline line = ((global::geometrize.rasterizer.Scanline) (lines[_g]) );
						 ++ _g;
						int y = line.y;
						{
							int _g1 = line.x1;
							int _g2 = ( line.x2 + 1 );
							while (( _g1 < _g2 )) {
								int x = _g1++;
								((int[]) (destination.data) )[( ( destination.width * y ) + x )] = ((int[]) (source.data) )[( ( source.width * y ) + x )];
							}
							
						}
						
					}
					
				}
				
			}
		}
		
		
		public static global::HaxeArray<object> bresenham(int x1, int y1, int x2, int y2) {
			unchecked {
				int dx = ( x2 - x1 );
				int ix = ( (( (( dx > 0 )) ? (1) : (0) )) - (( (( dx < 0 )) ? (1) : (0) )) );
				dx = ( (( (( dx < 0 )) ? ( - (dx) ) : (dx) )) << 1 );
				int dy = ( y2 - y1 );
				int iy = ( (( (( dy > 0 )) ? (1) : (0) )) - (( (( dy < 0 )) ? (1) : (0) )) );
				dy = ( (( (( dy < 0 )) ? ( - (dy) ) : (dy) )) << 1 );
				global::HaxeArray<object> points = new global::HaxeArray<object>(new object[]{});
				points.push(new global::haxe.lang.DynamicObject(new int[]{}, new object[]{}, new int[]{120, 121}, new double[]{((double) (x1) ), ((double) (y1) )}));
				if (( dx >= dy )) {
					int error = ( dy - (( dx >> 1 )) );
					while (( x1 != x2 )) {
						if (( ( error >= 0 ) && (( ( error != 0 ) || ( ix > 0 ) )) )) {
							error -= dx;
							y1 += iy;
						}
						
						error += dy;
						x1 += ix;
						points.push(new global::haxe.lang.DynamicObject(new int[]{}, new object[]{}, new int[]{120, 121}, new double[]{((double) (x1) ), ((double) (y1) )}));
					}
					
				}
				else {
					int error1 = ( dx - (( dy >> 1 )) );
					while (( y1 != y2 )) {
						if (( ( error1 >= 0 ) && (( ( error1 != 0 ) || ( iy > 0 ) )) )) {
							error1 -= dy;
							x1 += ix;
						}
						
						error1 += dx;
						y1 += iy;
						points.push(new global::haxe.lang.DynamicObject(new int[]{}, new object[]{}, new int[]{120, 121}, new double[]{((double) (x1) ), ((double) (y1) )}));
					}
					
				}
				
				return points;
			}
		}
		
		
		public static global::HaxeArray<object> scanlinesForPolygon(global::HaxeArray<object> points) {
			unchecked {
				global::HaxeArray<object> lines = new global::HaxeArray<object>(new object[]{});
				global::HaxeArray<object> edges = new global::HaxeArray<object>(new object[]{});
				{
					int _g = 0;
					int _g1 = points.length;
					while (( _g < _g1 )) {
						int i = _g++;
						object p1 = points[i];
						object p2 = ( (( i == ( points.length - 1 ) )) ? (points[0]) : (points[( i + 1 )]) );
						global::HaxeArray<object> p1p2 = global::geometrize.rasterizer.Rasterizer.bresenham(((int) (global::haxe.lang.Runtime.getField_f(p1, "x", 120, true)) ), ((int) (global::haxe.lang.Runtime.getField_f(p1, "y", 121, true)) ), ((int) (global::haxe.lang.Runtime.getField_f(p2, "x", 120, true)) ), ((int) (global::haxe.lang.Runtime.getField_f(p2, "y", 121, true)) ));
						edges = edges.concat(p1p2);
					}
					
				}
				
				global::haxe.ds.IntMap<object> yToXs = new global::haxe.ds.IntMap<object>();
				{
					int _g2 = 0;
					while (( _g2 < edges.length )) {
						object point = edges[_g2];
						 ++ _g2;
						global::HaxeArray<int> s = ((global::HaxeArray<int>) (global::HaxeArray<object>.__hx_cast<int>(((global::HaxeArray) ((yToXs.@get(((int) (global::haxe.lang.Runtime.getField_f(point, "y", 121, true)) ))).@value) ))) );
						if (( s != null )) {
							global::geometrize._ArraySet.ArraySet_Impl_.@add<int>(((global::HaxeArray<int>) (s) ), ((int) (global::haxe.lang.Runtime.getField_f(point, "x", 120, true)) ));
						}
						else {
							s = global::geometrize._ArraySet.ArraySet_Impl_.create<int>(default(global::HaxeArray<int>));
							global::geometrize._ArraySet.ArraySet_Impl_.@add<int>(((global::HaxeArray<int>) (s) ), ((int) (global::haxe.lang.Runtime.getField_f(point, "x", 120, true)) ));
							yToXs.@set(((int) (global::haxe.lang.Runtime.getField_f(point, "y", 121, true)) ), s);
						}
						
					}
					
				}
				
				{
					object key = ((object) (new global::haxe.ds._IntMap.IntMapKeyIterator<object>(((global::haxe.ds.IntMap<object>) (yToXs) ))) );
					while (global::haxe.lang.Runtime.toBool(global::haxe.lang.Runtime.callField(key, "hasNext", 407283053, null))) {
						int key1 = ((int) (global::haxe.lang.Runtime.toInt(global::haxe.lang.Runtime.callField(key, "next", 1224901875, null))) );
						global::HaxeArray<int> a = global::geometrize._ArraySet.ArraySet_Impl_.toArray<int>(((global::HaxeArray<int>) (global::HaxeArray<object>.__hx_cast<int>(((global::HaxeArray) ((yToXs.@get(key1)).@value) ))) ));
						object minMaxElements = null;
						if (( ( a == null ) || ( a.length == 0 ) )) {
							minMaxElements = new global::haxe.lang.DynamicObject(new int[]{}, new object[]{}, new int[]{120, 121}, new double[]{((double) (0) ), ((double) (0) )});
						}
						else {
							int min = a[0];
							int max = a[0];
							{
								int _g3 = 0;
								while (( _g3 < a.length )) {
									int @value = a[_g3];
									 ++ _g3;
									if (( min > @value )) {
										min = @value;
									}
									
									if (( max < @value )) {
										max = @value;
									}
									
								}
								
							}
							
							minMaxElements = new global::haxe.lang.DynamicObject(new int[]{}, new object[]{}, new int[]{120, 121}, new double[]{((double) (min) ), ((double) (max) )});
						}
						
						lines.push(new global::geometrize.rasterizer.Scanline(((int) (key1) ), ((int) (global::haxe.lang.Runtime.getField_f(minMaxElements, "x", 120, true)) ), ((int) (global::haxe.lang.Runtime.getField_f(minMaxElements, "y", 121, true)) )));
					}
					
				}
				
				return lines;
			}
		}
		
		
	}
}


