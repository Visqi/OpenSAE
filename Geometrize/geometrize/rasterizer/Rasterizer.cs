// Generated by Haxe 4.3.1


using System;

namespace geometrize.rasterizer
{
    public static class Rasterizer
    {

        public static void drawLines(bitmap.Bitmap image, int c, HaxeArray<object> lines)
        {
            unchecked
            {
                if (image == null)
                {
                    throw (Exception)haxe.Exception.thrown("FAIL: image != null");
                }

                if (lines == null)
                {
                    throw (Exception)haxe.Exception.thrown("FAIL: lines != null");
                }

                int sr = (c >> 24) & 255;
                sr |= sr << 8;
                sr *= c & 255;
                sr /= 255;

                int sg = (c >> 16) & 255;
                sg |= sg << 8;
                sg *= c & 255;
                sg /= 255;

                int sb = (c >> 8) & 255;
                sb |= sb << 8;
                sb *= c & 255;
                sb /= 255;

                int sa = c & 255;
                sa |= sa << 8;

                for (int i = 0; i < lines.length; i++)
                {
                    Scanline line = (Scanline)lines[i];
                    int y = line.y;
                    int ma = 65535;
                    int m = 65535;
                    int a = (m - sa) * 257;

                    for (int x = line.x1; x < line.x2 + 1; x++)
                    {
                        int d = image.data[(image.width * y) + x];
                        int dr = (d >> 24) & 255;
                        int dg = (d >> 16) & 255;
                        int db = (d >> 8) & 255;
                        int da = d & 255;
                        int r = ((int)(((double)((dr * a) + (sr * ma))) / m)) >> 8;
                        int g = ((int)(((double)((dg * a) + (sg * ma))) / m)) >> 8;
                        int b = ((int)(((double)((db * a) + (sb * ma))) / m)) >> 8;
                        int a1 = ((int)(((double)((da * a) + (sa * ma))) / m)) >> 8;

                        image.data[(image.width * y) + x] =
                            ((r > 255) ? 255 : r << 24) +
                            ((g > 255) ? 255 : g << 16) +
                            ((b > 255) ? 255 : b << 8) +
                            ((a1 > 255) ? 255 : a1);
                    }
                }
            }
        }


        public static void copyLines(bitmap.Bitmap destination, bitmap.Bitmap source, HaxeArray<object> lines)
        {
            unchecked
            {
                if (destination == null)
                {
                    throw (Exception)haxe.Exception.thrown("FAIL: destination != null");
                }

                if (source == null)
                {
                    throw (Exception)haxe.Exception.thrown("FAIL: source != null");
                }

                if (lines == null)
                {
                    throw (Exception)haxe.Exception.thrown("FAIL: lines != null");
                }

                for (int i = 0; i < lines.length; i++)
                {
                    Scanline line = (Scanline)lines[i];
                    
                    for (int x = line.x1; x < line.x2 + 1; x++)
                    {
                        destination.data[(destination.width * line.y) + x] = source.data[(source.width * line.y) + x];
                    }
                }
            }
        }


        public static HaxeArray<object> bresenham(int x1, int y1, int x2, int y2)
        {
            unchecked
            {
                int dx = x2 - x1;
                int ix = ((dx > 0) ? 1 : 0) - ((dx < 0) ? 1 : 0);
                dx = ((dx < 0) ? (-dx) : dx) << 1;
                int dy = y2 - y1;
                int iy = ((dy > 0) ? 1 : 0) - ((dy < 0) ? 1 : 0);
                dy = ((dy < 0) ? (-dy) : dy) << 1;
                HaxeArray<object> points = new HaxeArray<object>(new object[] { });
                points.push(new haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { x1, y1 }));
                if (dx >= dy)
                {
                    int error = dy - (dx >> 1);
                    while (x1 != x2)
                    {
                        if ((error >= 0) && ((error != 0) || (ix > 0)))
                        {
                            error -= dx;
                            y1 += iy;
                        }

                        error += dy;
                        x1 += ix;
                        points.push(new haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { x1, y1 }));
                    }

                }
                else
                {
                    int error1 = dx - (dy >> 1);
                    while (y1 != y2)
                    {
                        if ((error1 >= 0) && ((error1 != 0) || (iy > 0)))
                        {
                            error1 -= dy;
                            x1 += ix;
                        }

                        error1 += dx;
                        y1 += iy;
                        points.push(new haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { x1, y1 }));
                    }

                }

                return points;
            }
        }


        public static HaxeArray<object> scanlinesForPolygon(HaxeArray<object> points)
        {
            unchecked
            {
                HaxeArray<object> lines = new HaxeArray<object>(new object[] { });
                HaxeArray<object> edges = new HaxeArray<object>(new object[] { });
                {
                    int _g = 0;
                    int _g1 = points.length;
                    while (_g < _g1)
                    {
                        int i = _g++;
                        object p1 = points[i];
                        object p2 = (i == (points.length - 1)) ? points[0] : points[i + 1];
                        HaxeArray<object> p1p2 = bresenham((int)haxe.lang.Runtime.getField_f(p1, "x", 120, true), (int)haxe.lang.Runtime.getField_f(p1, "y", 121, true), (int)haxe.lang.Runtime.getField_f(p2, "x", 120, true), (int)haxe.lang.Runtime.getField_f(p2, "y", 121, true));
                        edges = edges.concat(p1p2);
                    }

                }

                haxe.ds.IntMap<object> yToXs = new haxe.ds.IntMap<object>();
                {
                    int _g2 = 0;
                    while (_g2 < edges.length)
                    {
                        object point = edges[_g2];
                        ++_g2;
                        HaxeArray<int> s = (HaxeArray<int>)HaxeArray<object>.__hx_cast<int>((HaxeArray)yToXs.@get((int)haxe.lang.Runtime.getField_f(point, "y", 121, true)).@value);
                        if (s != null)
                        {
                            _ArraySet.ArraySet_Impl_.@add(s, (int)haxe.lang.Runtime.getField_f(point, "x", 120, true));
                        }
                        else
                        {
                            s = _ArraySet.ArraySet_Impl_.create(default(HaxeArray<int>));
                            _ArraySet.ArraySet_Impl_.@add(s, (int)haxe.lang.Runtime.getField_f(point, "x", 120, true));
                            yToXs.@set((int)haxe.lang.Runtime.getField_f(point, "y", 121, true), s);
                        }

                    }

                }

                {
                    object key = new haxe.ds._IntMap.IntMapKeyIterator<object>(yToXs);
                    while (haxe.lang.Runtime.toBool(haxe.lang.Runtime.callField(key, "hasNext", 407283053, null)))
                    {
                        int key1 = haxe.lang.Runtime.toInt(haxe.lang.Runtime.callField(key, "next", 1224901875, null));
                        HaxeArray<int> a = _ArraySet.ArraySet_Impl_.toArray((HaxeArray<int>)HaxeArray<object>.__hx_cast<int>((HaxeArray)yToXs.@get(key1).@value));
                        object minMaxElements = null;
                        if ((a == null) || (a.length == 0))
                        {
                            minMaxElements = new haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { 0, 0 });
                        }
                        else
                        {
                            int min = a[0];
                            int max = a[0];
                            {
                                int _g3 = 0;
                                while (_g3 < a.length)
                                {
                                    int @value = a[_g3];
                                    ++_g3;
                                    if (min > @value)
                                    {
                                        min = @value;
                                    }

                                    if (max < @value)
                                    {
                                        max = @value;
                                    }

                                }

                            }

                            minMaxElements = new haxe.lang.DynamicObject(new int[] { }, new object[] { }, new int[] { 120, 121 }, new double[] { min, max });
                        }

                        lines.push(new Scanline(key1, (int)haxe.lang.Runtime.getField_f(minMaxElements, "x", 120, true), (int)haxe.lang.Runtime.getField_f(minMaxElements, "y", 121, true)));
                    }

                }

                return lines;
            }
        }
    }
}


